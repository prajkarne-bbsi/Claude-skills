---
description: Comprehensive guide for implementing CRUD APIs for Evaluation Criteria using FastAPI, SQLAlchemy, and Pydantic with a layered architecture pattern
---

# Evaluation Criteria API - Development Guide

This skill provides complete specifications for implementing the Evaluation Criteria API feature in a performance management backend using a layered architecture approach.

---

## üìÅ Project Structure

**Target Path**: `backend/api/v1/evaluation_criteria/`

**Required Files**:
- `schemas.py` - Pydantic models for request validation and response serialization
- `routes.py` - FastAPI endpoint definitions and route registration
- `controllers.py` - Request orchestration, response formatting, and error handling
- `services.py` - Business logic, data transformation, and validation rules
- `repository.py` - Database operations and SQLAlchemy queries

**Additional Required Files**:
- `backend/tests/evaluation_criteria_tests.py` - Comprehensive unit and integration tests for all API endpoints
- `backend/synthetic_data/evaluation_criteria.py` - Synthetic test data generator (separate from the API folder)

**IMPORTANT**: Do NOT generate any README, documentation, or summary markdown files during implementation. Only create the required Python files listed above.

---

## üèóÔ∏è Layered Architecture

**Layer Responsibilities**:
- **Routes**: Extract parameters, inject dependencies, pass to controller
- **Controller**: Extract user context, orchestrate operations, format responses, handle errors
- **Services**: Business logic, data transformation, validation, coordinate repository calls
- **Repository**: Database queries, transactions, CRUD operations

---

## üìä Database Model

**Table**: `evaluation_criteria`

| Column | Type | Description |
|--------|------|-------------|
| `id` | Integer (PK) | Primary key |
| `name` | String(120) | Criteria name |
| `description` | String(500) | Criteria description |
| `status` | String(1) | Status: "A" (Active) or "I" (Inactive) |
| `name_key` | String | Composite key: name + timestamp (for duplicate checking) |
| `company_id` | Integer (FK) | Company identifier |
| `created_by` | String | Email of creator |
| `created_date` | DateTime | Creation timestamp |
| `modified_date` | DateTime | Last modification timestamp |
| `is_delete_available` | Boolean | Whether record can be deleted |
| `is_update_available` | Boolean | Whether record can be updated |

**Important Notes**:
- **name_key Generation**: The `name_key` field is automatically generated by combining the criteria `name` with the current timestamp. This ensures uniqueness while allowing the system to check for duplicate names.
  - Format: `"{name}_{timestamp}"` (e.g., `"Leadership Skills_1703336400"`)
  - The timestamp component ensures each record has a unique key even if names are reused
  - Duplicate checking compares only the `name` portion, not the full `name_key`

---

## üìù API Specifications

### 1. **GET** `/evaluation-criteria` - List/Search Evaluation Criteria

**Query Parameters**:
- `q` (optional, string): Search term for filtering by name
- `status_filter` (optional, string): Filter by status ("A" or "I")
- `page` (optional, integer, default=1): Page number for pagination

**Authentication**: Required (JWT token via `user_detail` dependency)

**Flow**:
1. **Routes**: Extract query parameters, inject `db` and `user_detail` dependencies
2. **Controller**: Extract `company_id` from `user_detail.company_id`, pass to service
3. **Service**: Apply filters, calculate pagination, retrieve data
4. **Repository**: Execute database query with filters

**Service Logic**:
- Apply search filter on `name` if `q` is provided
- Apply status filter if `status_filter` is provided
- Filter by `company_id`
- Calculate pagination (items per page, total pages, start/end index)
- Return paginated results

**Response Format**:
```json
{
  "is_error": false,
  "message": "Evaluation criteria fetched successfully.",
  "payload": {
    "total_items": 50,
    "total_pages": 5,
    "start_index": 0,
    "end_index": 10,
    "items": [
      {
        "id": 1,
        "name": "Technical Skills",
        "description": "Assess technical competencies",
        "status": "A",
        "is_delete_available": true,
        "is_update_available": true,
        "created_date": "2025-01-15T10:30:00",
        "modified_date": "2025-01-20T14:45:00"
      }
    ]
  }
}
```

**Status Code**: `200 OK`

---

### 2. **POST** `/evaluation-criteria` - Create New Evaluation Criteria

**Request Body** (JSON):
```json
{
  "name": "Leadership Skills",
  "description": "Evaluate leadership and management capabilities",
  "status": "A"
}
```

**Validation Rules**:
- `name`: Required, min length 1, max length 120
- `description`: Required, min length 1, max length 500
- `status`: Required, must be either "A" or "I"

**Authentication**: Required (JWT token via `user_detail` dependency)

**Flow**:
1. **Routes**: Parse request body, inject `db` and `user_detail` dependencies
2. **Controller**: Extract `company_id` and `email` from `user_detail`, pass to service
3. **Service**: Validate uniqueness, prepare data, call repository
4. **Repository**: Insert record into database

**Service Logic**:
- Generate `name_key` by combining the `name` with the current timestamp (e.g., `"Leadership Skills_1703336400"`)
- Check if a criteria with the same `name` already exists for the `company_id` (duplicate check)
- If duplicate found, return `400 Bad Request` with error message
- Set `created_by` to `user_detail.email`
- Set `created_date` and `modified_date` to current timestamp
- Set `company_id` from `user_detail.company_id`
- Call repository to insert record

**Response Format**:
```json
{
  "is_error": false,
  "message": "Criteria saved successfully",
  "payload": {
    "id": 2,
    "name": "Leadership Skills",
    "description": "Evaluate leadership and management capabilities",
    "status": "A",
    "is_delete_available": true,
    "is_update_available": true,
    "created_date": "2025-12-23T10:30:00",
    "modified_date": "2025-12-23T10:30:00"
  }
}
```

**Status Code**: `201 Created`

**Error Scenarios**:
- Duplicate name: `400 Bad Request` - "Evaluation criteria with this name already exists"
- Validation error: `422 Unprocessable Entity` - Field-specific validation messages

---

### 3. **PUT** `/evaluation-criteria/{criteria_id}` - Update Evaluation Criteria

**Path Parameters**:
- `criteria_id` (integer): ID of the evaluation criteria to update

**Request Body** (JSON):
```json
{
  "name": "Advanced Leadership Skills",
  "description": "Updated description for leadership evaluation",
  "status": "A"
}
```

**Validation Rules**:
- `name`: Required, min length 1, max length 120
- `description`: Required, min length 1, max length 500
- `status`: Required, must be either "A" or "I"

**Authentication**: Required (JWT token via `user_detail` dependency)

**Flow**:
1. **Routes**: Extract path parameter and request body, inject dependencies
2. **Controller**: Extract `company_id` and `email` from `user_detail`, pass to service
3. **Service**: Validate existence and uniqueness, update data, call repository
4. **Repository**: Update record in database

**Service Logic**:
- Verify that criteria with `criteria_id` exists for the `company_id`
- Generate `name_key` by combining the updated `name` with current timestamp
- Check if a criteria with the same `name` already exists for another criteria (exclude current record)
- If duplicate found, return `400 Bad Request` with error message
- Update `name`, `description`, and `status`
- Update `modified_date` to current timestamp
- Call repository to update record

**Response Format**:
```json
{
  "is_error": false,
  "message": "Criteria updated successfully",
  "payload": {
    "id": 2,
    "name": "Advanced Leadership Skills",
    "description": "Updated description for leadership evaluation",
    "status": "A",
    "is_delete_available": true,
    "is_update_available": true,
    "created_date": "2025-12-23T10:30:00",
    "modified_date": "2025-12-23T15:45:00"
  }
}
```

**Status Code**: `200 OK`

**Error Scenarios**:
- Criteria not found: `404 Not Found` - "Evaluation criteria not found"
- Duplicate name: `400 Bad Request` - "Evaluation criteria with this name already exists"
- Validation error: `422 Unprocessable Entity` - Field-specific validation messages

---

### 4. **DELETE** `/evaluation-criteria/{criteria_id}` - Delete Evaluation Criteria

**Path Parameters**:
- `criteria_id` (integer): ID of the evaluation criteria to delete

**Authentication**: Required (JWT token via `user_detail` dependency)

**Flow**:
1. **Routes**: Extract path parameter, inject dependencies
2. **Controller**: Extract `company_id` from `user_detail`, pass to service
3. **Service**: Validate existence and deletability, call repository
4. **Repository**: Delete record from database

**Service Logic**:
- Verify that criteria with `criteria_id` exists for the `company_id`
- Verify that `is_delete_available` is `true`
- Call repository to delete record

**Response Format**:
```json
{
  "is_error": false,
  "message": "Criteria removed successfully",
  "payload": {
    "id": 2
  }
}
```

**Status Code**: `200 OK`

**Error Scenarios**:
- Criteria not found: `404 Not Found` - "Evaluation criteria not found"
- Delete not allowed: `403    Forbidden` - "This criteria cannot be deleted"

---

## üõ†Ô∏è Implementation Guidelines

### Response Handling

**IMPORTANT**: All controller methods must return responses using the existing `ResponseBuilder.success()` method with `message` and `payload` parameters. The ResponseBuilder class automatically sets `is_error=false` for all success responses.

### Error Handling

Use **try-except blocks** in all layers to handle exceptions gracefully.

**Important Notes**:
- **Success responses**: Always use `ResponseBuilder.success(message, payload)`
- **Error responses**: Raise `HTTPException` with appropriate status code and detail message
- The ResponseBuilder automatically sets `is_error=false` for success responses
- FastAPI will handle error responses and format them appropriately

**Duplicate Name Handling**:
- When a duplicate name is detected in the service layer, raise a custom exception
- In the controller, catch the exception and raise `HTTPException` with status code `400 Bad Request`

### HTTP Status Codes

Use appropriate status codes for different scenarios:

| Status Code | Usage |
|-------------|-------|
| `200 OK` | Successful GET, PUT, DELETE operations |
| `201 Created` | Successful POST (resource creation) |
| `400 Bad Request` | Validation errors, duplicate entries, business rule violations |
| `403 Forbidden` | Authorization issues, operation not permitted |
| `404 Not Found` | Resource not found |
| `422 Unprocessable Entity` | Request validation errors (Pydantic) |
| `500 Internal Server Error` | Unexpected server errors |

### Logging

Use the application logger to track operations and errors.

**Log Levels**:
- **DEBUG**: Detailed diagnostic information
- **INFO**: Business operations (create, update, delete)
- **WARNING**: Business rule violations, non-critical issues
- **ERROR**: Exceptions and errors with stack traces

### Dependencies

All endpoints require the following common dependencies that are already implemented in the codebase:

- **Database Session** (`db: Session = Depends(get_db)`)
  - Already implemented as a common dependency
  - Provides database session for all database operations
  - Import from: `app.dependencies.auth` and `sqlalchemy.orm`

- **User Authentication** (`user_detail = Depends(get_current_user)`)
  - Already implemented as a common dependency
  - Validates JWT token and returns user information
  - Import from: `app.dependencies.auth`

**Available user_detail fields**:
- `user_detail.email` - User's email address
- `user_detail.company_id` - Company identifier
- `user_detail.user_id` - User identifier
   ```python
   user_detail = Depends(get_current_user)
   ```
   - Already implemented as a common dependency
   - Validates JWT token and returns user information
   - Just import and use in your route function parameters

**Example Route with Dependencies**:
```python
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
from app.dependencies.auth import get_db, get_current_user

router = APIRouter()

@router.get("/evaluation-criteria")
async def get_evaluation_criteria(
    db: Session = Depends(get_db),
    user_detail = Depends(get_current_user),
    q: str = None,
    status_filter: str = None,
    page: int = 1
):
    # Access user information
    company_id = user_detail.company_id
    email = user_detail.email
**Available user_detail fields**:
- `user_detail.email` - User's email address
- `user_detail.company_id` - Company identifier
- `user_detail.user_id` - User identifier

### Response Builder Pattern

The **Response Builder** class is already implemented in the codebase and should be used for all API responses.

**Usage**: `ResponseBuilder.success(message="Your message", payload=data)`

**Parameters**:
- `message` (string): Human-readable message about the operation
- `payload` (object/array/dict): The actual data being returned

**Response Structure** (automatically generated):
```json
{
  "is_error": false,
  "message": "Your message here",
  "payload": { /* your data here */ }
}
```

**Notes**:
- The `success` method automatically sets `is_error` to `false`
- Always call `ResponseBuilder.success()` with both `message` and `payload` parameters
- For error responses, raise appropriate HTTPException with status codes

### Pagination

For GET operations, implement pagination with the following structure:
- `total_items` - Total number of records
- `total_pages` - Total number of pages
- `start_index` - Starting index of current page
- `end_index` - Ending index of current page
- `items` - List of records

**Pagination Logic**:
- Default page size: 10 items per page
- Calculate `total_pages` = `ceil(total_items / page_size)`
- Calculate `start_index` = `(page - 1) * page_size`
- Calculate `end_index` = `min(start_index + page_size, total_items)`
---

## üì¶ Pydantic Schemas Reference

### Request Schemas

**EvaluationCriteriaCreate**:
- `name`: str (min_length=1, max_length=120)
- `description`: str (min_length=1, max_length=500)
- `status`: str (must be "A" or "I")

**EvaluationCriteriaUpdate**:
- `name`: str (min_length=1, max_length=120)
- `description`: str (min_length=1, max_length=500)
- `status`: str (must be "A" or "I")

### Response Schemas

**EvaluationCriteriaResponse**:
- `id`: int
- `name`: str
- `description`: str
- `status`: str
- `is_delete_available`: bool
- `is_update_available`: bool
- `created_date`: datetime
- `modified_date`: datetime

**EvaluationCriteriaListResponse**:
- `total_items`: int
- `total_pages`: int
- `start_index`: int
- `end_index`: int
- `items`: List[EvaluationCriteriaResponse]

---

## üß™ Synthetic Test Data Generation

For testing purposes, generate synthetic evaluation criteria data that follows realistic patterns.

**File to Generate**: `seed_data_generator.py` in the target path

**Requirements**:
- Generate 20-30 realistic evaluation criteria records
- Include diverse criteria names covering different performance aspects:
  - Technical skills (e.g., "Programming Proficiency", "System Design")
  - Soft skills (e.g., "Communication Skills", "Teamwork")
  - Leadership (e.g., "Leadership Abilities", "Decision Making")
  - Performance metrics (e.g., "Goal Achievement", "Quality of Work")
- Mix of Active ("A") and Inactive ("I") statuses (80% Active, 20% Inactive)
- Realistic descriptions (50-200 characters)
- Multiple company IDs (e.g., 1, 2, 3) for testing multi-tenancy
- Varied created_by emails (e.g., "admin@company1.com", "manager@company2.com")
- Timestamps spread over the last 6 months
- All records should have `is_delete_available=True` and `is_update_available=True`

**Generator Features**:
- Function to generate individual criteria with random but realistic data
- Function to generate bulk data (configurable count)
- Function to insert data into database using the repository
- Option to clear existing test data before insertion
- Print summary of generated data (count by status, company, etc.)

**File Location**: Create this file in `backend/synthetic_data/evaluation_criteria.py` (separate folder for synthetic data generators)

**Usage Example**:
```python
# Run from backend directory
python -m synthetic_data.evaluation_criteria
```

---

## üß™ Testing

**File to Generate**: `backend/tests/evaluation_criteria_tests.py`

**Test Requirements**:
- Comprehensive unit tests for all service layer methods
- Integration tests for all API endpoints (GET, POST, PUT, DELETE)
- Test cases for successful operations
- Test cases for error scenarios (404, 400, 403, etc.)
- Test pagination logic
- Test search and filtering functionality
- Test duplicate name detection
- Test company isolation (multi-tenancy)
- Test authentication and authorization
- Mock database and user authentication where appropriate

**Test Structure**:
- Use pytest framework
- Organize tests into classes by functionality
- Use fixtures for common setup (database, test data, mock users)
- Include setup and teardown for test data
- Meaningful test names that describe what is being tested

**Example Test Categories**:
```python
class TestEvaluationCriteriaSchemas:
    # Test Pydantic schema validation
    
class TestEvaluationCriteriaRepository:
    # Test database operations
    
class TestEvaluationCriteriaService:
    # Test business logic
    
class TestEvaluationCriteriaAPI:
    # Test API endpoints (integration tests)
```

**Usage Example**:
```bash
# Run all tests
pytest backend/tests/evaluation_criteria_tests.py

# Run with coverage
pytest backend/tests/evaluation_criteria_tests.py --cov=api.v1.evaluation_criteria
```

---


## ‚úÖ Success Criteria

- All endpoints return proper status codes
- All validation rules are enforced
- Duplicate detection works correctly
- Pagination functions properly
- Error handling is comprehensive
- Logging captures all critical operations
- Response format is consistent across all endpoints
- Authentication and authorization are properly implemented
